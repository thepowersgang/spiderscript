/*
 * Acess2 - SpiderScript
 * - Script Exports (Lang. Namespace)
 */
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <spiderscript.h>

@FUNCTION Integer sizeof( * Value )
@{
	if( SS_GETARRAYDEPTH( @TYPEOF(Value) ) )
	{
		@RETURN @ARRAY(Value)->Length;
	}

	if( SS_ISTYPEOBJECT( @TYPEOF(Value) ) )
	{
		@RETURN 0;
	}	

	switch( @TYPEOF(Value) )
	{
	case SS_DATATYPE_STRING:
		@RETURN @STRING(Value)->Length;
	default:
		@RETURN 0;
	}
@}

@FUNCTION void exit()
@{
	exit(0);
//	return -1;	// TODO: Return RV_CLEANEXIT
@}

@FUNCTION Boolean isnull( * Value )
@{
	if( !Value )
		@RETURN 1;
	@RETURN 0;
@}

@NAMESPACE Lang
@{

@CLASS StringMap
@{
	typedef struct s_StringMap_Entry	t_StringMap_Entry;
	struct s_StringMap_Entry
	{
		t_StringMap_Entry	*Next;
		const tSpiderString	*Key;
		const tSpiderString	*Value;
	};
	#define N_STRINGMAP_BUCKETS	256
	typedef struct
	{
		 int	nItems;
		t_StringMap_Entry	*Buckets[N_STRINGMAP_BUCKETS];
	} t_StringMap_Info;
	@CONSTRUCTOR ()
	@{
		tSpiderObject	*this;

		this = SpiderScript_AllocateObject(Script, @CLASSPTR, sizeof(t_StringMap_Info));		

		t_StringMap_Info *info = this->OpaqueData;
		info->nItems = 0;
		memset(info->Buckets, 0, sizeof(info->Buckets));
		
		@RETURN this;
	@}
	@DESTRUCTOR
	@{
		t_StringMap_Info *info = this->OpaqueData;
		for( int i = 0; i < N_STRINGMAP_BUCKETS; i ++ )
		{
			t_StringMap_Entry	*e, *p;
			
			for( e = info->Buckets[i]; e; e = p )
			{
				p = e->Next;
				SpiderScript_DereferenceString(e->Key);
				SpiderScript_DereferenceString(e->Value);
				free(e);
			}
		}
	@}

	@FUNCTION void set(String Key, String Value)
	@{
		t_StringMap_Info *info = this->OpaqueData;
		if( !Key )	@RETURN ;

		t_StringMap_Entry	**bucket;
		if( Key->Length == 0 )
			bucket = &info->Buckets[0];
		else
			bucket = &info->Buckets[ (int)Key->Data[0] ];
		
		t_StringMap_Entry	*e, *p = NULL;
		for( e = *bucket; e; p = e, e = e->Next )
		{
			// Length sorted
			if( e->Key->Length > Key->Length )	break;
			if( e->Key->Length < Key->Length )	continue;
			// Data sorted
			int cmp = memcmp(e->Key->Data, Key->Data, Key->Length);
			if( cmp > 0 )	break;
			if( cmp < 0 )	continue ;
			
			// Ok, just update this then
			SpiderScript_DereferenceString(e->Value);
			SpiderScript_ReferenceString(Value);
			e->Value = Value;
			@RETURN ;
		}
		
		e = malloc(sizeof(*e));
		SpiderScript_ReferenceString(Key);
		e->Key = Key;
		SpiderScript_ReferenceString(Value);
		e->Value = Value;
		if( p ) {
			e->Next = p->Next;
			p->Next = e;
		}
		else {
			e->Next = *bucket;
			*bucket = e;
		}
		info->nItems ++;
	@}

	@FUNCTION String get(String Key)
	@{
		t_StringMap_Info *info = this->OpaqueData;
		if( !Key )	@RETURN NULL;

		t_StringMap_Entry	**bucket;
		if( Key->Length == 0 )
			bucket = &info->Buckets[0];
		else
			bucket = &info->Buckets[ (int)Key->Data[0] ];

		t_StringMap_Entry	*e;
		for( e = *bucket; e; e = e->Next )
		{
			// Length sorted
			if( e->Key->Length > Key->Length )	break;
			if( e->Key->Length < Key->Length )	continue;
			// Data sorted
			int cmp = memcmp(e->Key->Data, Key->Data, Key->Length);
			if( cmp > 0 )	break;
			if( cmp < 0 )	continue ;
			
			// Ok, just update this then
			SpiderScript_ReferenceString(e->Value);
			@RETURN e->Value;
		}
		@RETURN NULL;
	@}

	@FUNCTION String[] keys()
	@{
		t_StringMap_Info *info = this->OpaqueData;
		tSpiderArray	*ret = SpiderScript_CreateArray(SS_DATATYPE_STRING, info->nItems);
		 int	j = 0;		

		for( int i = 0; i < N_STRINGMAP_BUCKETS; i ++ )
		{
			t_StringMap_Entry	*e;
			
			for( e = info->Buckets[i]; e; e = e->Next ) {
				SpiderScript_ReferenceString(e->Key);
				ret->Strings[j++] = (void*)e->Key;
			}
		}
		
		@RETURN ret;
	@}
@}

int compare_spiderstring_ptrs(const void *s1, const void *s2)
{
	const tSpiderString	* const *strp1 = s1, * const *strp2 = s2;

	if( !*strp1 && !*strp2 )
		return 0;
	else if( !*strp1 )
		return 1;	// NULL sorts to the end
	else if( !*strp2 )
		return -1;
	else
		return SpiderScript_StringCompare(*strp1, *strp2);
}

@FUNCTION String[] SortStrings(String[] Input)
@{
	if( !Input )
		@RETURN NULL;
	
	tSpiderArray	*ret = SpiderScript_CreateArray(SS_DATATYPE_STRING, Input->Length);
	for( int i = 0; i < Input->Length; i ++ ) {
		ret->Strings[i] = Input->Strings[i];
		if( ret->Strings[i] )
			SpiderScript_ReferenceString(ret->Strings[i]);
	}
	qsort(ret->Strings, ret->Length, sizeof(ret->Strings[0]), compare_spiderstring_ptrs);
	@RETURN ret;
@}

@NAMESPACE Strings
@{

// Because memmem is a GNU extension, I'll just impliment it myself
const void *memmem(const void *haystack, size_t haystacklen, const void *needle, size_t needlelen)
{
	 int	ofs;
	if( haystacklen < needlelen )
		return NULL;
	for( ofs = 0; ofs < haystacklen - needlelen; ofs ++ )
	{
		if( memcmp(haystack + ofs, needle, needlelen) == 0 )
			return haystack + ofs;
	}
	return NULL;
}

@FUNCTION String[] Split(String Haystack, String Needle)
@{
	 int	haystack_len, needle_len;
	const void	*haystack, *needle, *end;
	 int	ofs, slen;
	tSpiderString	**strings = NULL;
	 int	nSubStrs = 0;
	
	// Split the string
	haystack_len = Haystack->Length;
	haystack     = Haystack->Data;
	needle_len = Needle->Length;
	needle     = Needle->Data;
	ofs = 0;
	do {
		end = memmem(haystack + ofs, haystack_len - ofs, needle, needle_len);
		if( end )
			slen = end - (haystack + ofs);
		else
			slen = haystack_len - ofs;
		
		strings = realloc(strings, (nSubStrs+1)*sizeof(tSpiderString*));
		strings[nSubStrs] = SpiderScript_CreateString(slen, haystack + ofs);
		nSubStrs ++;

		ofs += slen + needle_len;
	} while(end);

	// Create output array
	tSpiderArray *ret = SpiderScript_CreateArray(SS_DATATYPE_STRING, nSubStrs);
	memcpy(ret->Strings, strings, nSubStrs*sizeof(tSpiderString*));
	free(strings);

	@RETURN ret;
@}

@FUNCTION Integer Search(String Haystack, String Needle)
@{
	if( !Haystack || !Needle )
		@RETURN -1;
	
	const char *end = memmem(Haystack->Data, Haystack->Length, Needle->Data, Needle->Length);
	if( !end )
		@RETURN -1;
	
	@RETURN end - Haystack->Data;
@}

@FUNCTION String SubStr(String Input, Integer Offset, Integer Length)
@{
	if( !Input )
		@RETURN NULL;
	if( Offset > Input->Length )
		@RETURN SpiderScript_CreateString(0, NULL);
	if( Length > Input->Length )
		Length = Input->Length;
	if( Offset + Length > Input->Length )
		Length = Input->Length - Offset;
	if( Length == 0 )
		@RETURN SpiderScript_CreateString(0, NULL);
	
	@RETURN SpiderScript_CreateString(Length, Input->Data + Offset);
@}

@FUNCTION String Replace(String Haystack, String Needle, String Replacement)
@{
	if( !Haystack )
		@RETURN NULL;
	if( !Needle || !Replacement ) {
		SpiderScript_ReferenceString(Haystack);
		@RETURN Haystack;
	}

	// Pass 1 - Count replacements
	const char *pos;
	 int	ofs = 0;
	 int	nMatches = 0;
	 int	slen;
	do {
		pos = memmem(Haystack->Data + ofs, Haystack->Length - ofs, Needle->Data, Needle->Length);
		if( pos )
			slen = pos - (Haystack->Data + ofs);
		else
			slen = Haystack->Length - ofs;

		if( pos )
			nMatches ++;	

		ofs += slen + Needle->Length;
	} while(pos);

	// Pass 2 - Build new string
	size_t	newlen = Haystack->Length - nMatches*Needle->Length + nMatches*Replacement->Length;
	tSpiderString *ret = SpiderScript_CreateString(newlen, NULL);
	 int	write_ofs = 0;
	ofs = 0;
	do {
		pos = memmem(Haystack->Data + ofs, Haystack->Length - ofs, Needle->Data, Needle->Length);
		if( pos )
			slen = pos - (Haystack->Data + ofs);
		else
			slen = Haystack->Length - ofs;

		memcpy(ret->Data + write_ofs, Haystack->Data + ofs, slen);
		write_ofs += slen;
		if( pos ) {
			memcpy(ret->Data + write_ofs, Replacement->Data, Replacement->Length);
			write_ofs += Replacement->Length;
		}

		ofs += slen + Needle->Length;
	} while(pos);
	
	@RETURN ret;
@}

// TODO: RegexReplace

@} // NAMESPACE Strings	
@} // NAMESPACE Lang

// vim: ft=c
